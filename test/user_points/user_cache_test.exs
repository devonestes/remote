defmodule UserPoints.UserCacheTest do
  use UserPoints.DataCase, async: true

  alias UserPoints.{Repo, UserCache, Users}

  describe "start_link/1" do
    setup do
      :erlang.trace(:new_processes, true, [{:tracer, self()}, :receive])
      {:ok, pid} = start_supervised(UserCache)
      Ecto.Adapters.SQL.Sandbox.allow(Repo, self(), pid)
      {:ok, cache: pid}
    end

    test "starts a cache and schedules a recurring refresh", %{cache: cache} do
      assert_receive {:trace, ^cache, :receive, :refresh}
      assert {max_number, nil} = :sys.get_state(cache)
      assert max_number >= 0
      assert max_number <= 100

      assert_receive {:trace, ^cache, :receive, :refresh}
      assert {new_number, nil} = :sys.get_state(cache)
      assert new_number >= 0
      assert new_number <= 100
      assert max_number != new_number
    end

    test "the refresh resets the state for all users in the DB when it runs", %{cache: cache} do
      Users.create_user(200)
      Users.create_user(200)

      # This is async, so we use a little retry behavior here
      assert_receive {:trace, ^cache, :receive, :refresh}
      retry(3, fn ->
        assert [user1, user2] = Users.list_users()
        assert user1.points != 200
        assert user2.points != 200
      end)
    end
  end

  describe "get_users/0" do
    test "returns no more than two users" do
      # Create three users, all of which have points higher than the maximum random points
      # generated by the cache
      Users.create_user(200)
      Users.create_user(201)
      Users.create_user(202)

      {:ok, cache} = start_supervised(UserCache)
      Ecto.Adapters.SQL.Sandbox.allow(Repo, self(), cache)

      assert {[_, _], nil} = UserCache.get_users(cache)
    end

    test "sets the timestamp correctly" do
      {:ok, cache} = start_supervised(UserCache)
      Ecto.Adapters.SQL.Sandbox.allow(Repo, self(), cache)
      Ecto.Adapters.SQL.Sandbox.allow(Repo, self(), cache)

      starting = DateTime.utc_now() |> DateTime.to_unix()
      assert {_, nil} = UserCache.get_users(cache)
      ending = DateTime.utc_now() |> DateTime.to_unix()

      assert {_, timestamp} = :sys.get_state(cache)
      assert timestamp >= starting
      assert timestamp <= ending
    end
  end

  defp retry(0, fun) do
    fun.()
  end

  defp retry(retries, fun) do
    fun.()
  rescue
    _ in [ExUnit.AssertionError] -> retry(retries - 1, fun)
  end
end
